## 1. 사용자의 액션 수 집계하기 

### 액션 수와 비율을 계산하는 쿼리
```sql
WITH stats AS(
  SELECT COUNT(DISTINCT session) AS total_uu
  FROM action_log
)
SELECT l.action
-- 액션 UU
	,COUNT(DISTINCT l.session) AS action_uu
-- 액션의 수     
    ,COUNT(1) AS action_count
-- 전체 UU
	,s.total_uu
-- 사용률 : 액션 uu / 전체 uu 
	,COUNT(DISTINCT l.session)*100.0 / s.total_uu AS usage_rate
-- 1인당 액션 수 : 액션 수 / 액션 uu
	,COUNT(1)*1.0/COUNT(DISTINCT l.session) AS count_per_user    
FROM action_log AS l 
```
### 로그인 상태를 판별하는 쿼리 
```sql
WITH action_log_with_status AS(
  
  SELECT   session
          ,user_id
          ,action
          -- user_id가 NULL 또는 빈 문자가 아닌 경우 login이라고 판정하기
          ,CASE WHEN COALESCE(user_id,'')<>'' THEN 'login' ELSE 'guest' END
           AS login_status
  FROM action_log
  )
```
### 로그인 상태에 따라 액션 수 등을 따로 집계하는 쿼리 
```sql
WITH action_log_with_status AS(
  
  SELECT   session
          ,user_id
          ,action
          -- user_id가 NULL 또는 빈 문자가 아닌 경우 login이라고 판정하기
          ,CASE WHEN COALESCE(user_id,'')<>'' THEN 'login' ELSE 'guest' END
           AS login_status
  FROM action_log
  )
SELECT 
	 COALESCE(action, 'all') AS action
	,COALESCE(login_status,'all') AS login_status
    ,COUNT(DISTINCT session) AS action_uu
    ,COUNT(1) AS action_count
FROM action_log_with_status
GROUP BY ROLLUP(action, login_status)
-- 로그인 상태에 따라 액션 수를 따로 집계
```
### 회원과 비회원을 구분해서 집계하기 

```sql
WITH action_log_with_status AS(
  
  SELECT   session
          ,user_id
          ,action
          -- 로그를 타임스탬프 순서로 나열하고, 한번이라도 로그인한 사용자일 경우
  		  -- 이후의 모든 로그 상태를 member로 설정
  		  ,CASE
  			WHEN
  				COALESCE(MAX(user_id)
  				OVER(PARTITION BY session ORDER BY stamp
                     ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  				,'') <> ''
                THEN 'member'
            ELSE 'none'
           END AS member_status
          ,stamp 
  FROM action_log
  )
SELECT * 
FROM action_log_with_status
```
## 2. 연령별 구분 집계하기 

### 사용자의 생일을 계산하는 쿼리 
```sql
WITH mst_users_with_int_birth_date AS(
  SELECT
      *
      -- 특정 날짜(2017년 1월 1일)의 정수 표현
     ,20170101 AS int_specific_date
      -- 문자열로 구성된 생년월일을 정수 표현으로 변환하기
     ,CAST(replace(substring(birth_date,1,10),'-','' ) AS integer) AS int_birth_date
  FROM mst_users

),mst_users_with_age AS (
  SELECT
  	*
   -- 특정 날짜(2017년 1월 1일)의 나이
   ,FLOOR((int_specific_date -  int_birth_date) / 10000) AS age
  FROM mst_users_with_int_birth_date

)
SELECT 
	user_id
   ,sex
   ,birth_date
   ,age
FROM mst_users_with_age;
```

#### CAST 
- 형 변환 함수 
- CAST(컬럼명, 값 AS 변경하려는 TYPE명)
- 영단어 뜻을 찾아보니 주조하다, 거푸집 이런 것들이 있어서 비슷한 결이 아닐까 싶다. 

#### Q : 왜 굳이 substring으로 잘라줄까? 
```CAST(replace(substring(birth_date,1,10),'-','' ) AS integer) AS int_birth_date```
- birth_date 어차피 1에서 10인데..?
- 이 날짜를 이 특정 형식으로 변환하는 이유는 날짜 형식의 다양성과 관련된 잠재적인 문제를 방지하고 날짜의 정수 표현에 표준화된 접근을 보장하기 위함입니다. 이렇게 함으로써 날짜 형식의 변형과 관련된 잠재적인 문제를 방지하고 날짜의 정수 표현에 표준화된 접근을 보장합니다.
  - ChatGPT가 그렇대
 
#### Floor
- 말 그대로 바닥, 마루
- 소수점 무시

## 3. 사용자의 방문 빈도 집계하기   

### 한 주에 며칠 사용되었는지를 집계하는 쿼리 
```sql
WITH action_log_with_dt AS(
  SELECT * 
  		,substr(stamp,1,10) AS dt 
  FROM action_log
  
), action_day_count_per_user AS(
  SELECT 
 	user_id
  , COUNT(DISTINCT dt) AS action_day_cnt
  FROM action_log_with_dt
  GROUP BY user_id

)
SELECT 
	action_day_cnt
   ,COUNT(DISTINCT user_id) AS user_count
FROM action_day_count_per_user
GROUP BY 1
ORDER BY 1;

```

## 4. 벤다이어그램으로 사용자 액션 집계하기 

### 사용자들의 액션 플래그를 집계하는 쿼리 
```sql
WITH user_action_flag AS(
  -- 사용자가 액션을 했으면 1, 안했으면 0으로 플래그 붙이기 
  SELECT  
      user_id
     ,SIGN(SUM(CASE WHEN action = 'purchase' THEN 1 ELSE 0 END)) AS has_purchased
     ,SIGN(SUM(CASE WHEN action = 'review' THEN 1 ELSE 0 END)) AS has_review 
     ,SIGN(SUM(CASE WHEN action = 'favorite' THEN 1 ELSE 0 END)) AS favorite    
  FROM action_log
  GROUP BY user_id
)
SELECT * 
FROM user_action_flag;
```

#### SIGN
- 양수,0,음수 판단해주는 함수
- The SIGN() function returns the sign of a number.
	- If number > 0, it returns 1
	- If number = 0, it returns 0
	- If number < 0, it returns -1

### 모든 액션 조합에 대한 사용자 수 계산하기 
```sql
WITH user_action_flag AS(
  -- 사용자가 액션을 했으면 1, 안했으면 0으로 플래그 붙이기 
  SELECT  
      user_id
     ,SIGN(SUM(CASE WHEN action = 'purchase' THEN 1 ELSE 0 END)) AS has_purchased
     ,SIGN(SUM(CASE WHEN action = 'review' THEN 1 ELSE 0 END)) AS has_review 
     ,SIGN(SUM(CASE WHEN action = 'favorite' THEN 1 ELSE 0 END)) AS has_favorite    
  FROM action_log
  GROUP BY user_id

), action_venn_diagram AS (
  -- CUBE를 사용해서 모든 액션 조합 구하기 
  SELECT 
  	has_purchased
  , has_review
  , has_favorite
  , COUNT(1) AS users
  FROM user_action_flag
  GROUP BY CUBE(has_purchased,has_review,has_favorite)
  )
  SELECT *
  FROM action_venn_diagram 
  ORDER BY 1,2,3
```
#### CUBE
- 모든 소계에 대한 그룹 합계 제공
- 컬럼끼리들의 합계, 총계 제공 미들웨어에 따라 사용 제한적

### 벤 다이어그램을 만들기 위해 데이터를 가공하는 쿼리 
```sql
WITH user_action_flag AS(
  -- 사용자가 액션을 했으면 1, 안했으면 0으로 플래그 붙이기 
  SELECT  
      user_id
     ,SIGN(SUM(CASE WHEN action = 'purchase' THEN 1 ELSE 0 END)) AS has_purchase
     ,SIGN(SUM(CASE WHEN action = 'review' THEN 1 ELSE 0 END)) AS has_review 
     ,SIGN(SUM(CASE WHEN action = 'favorite' THEN 1 ELSE 0 END)) AS has_favorite    
  FROM action_log
  GROUP BY user_id

), action_venn_diagram AS (
  -- CUBE를 사용해서 모든 액션 조합 구하기 
  SELECT 
  	has_purchase
  , has_review
  , has_favorite
  , COUNT(1) AS users
  FROM user_action_flag
  GROUP BY CUBE(has_purchase,has_review,has_favorite)
  )
  SELECT 
  -- 0,1 플래그를 문자열로 가공하기 
    CASE has_purchase
      WHEN 1 THEN 'purchase' WHEN 0 THEN 'not purchase' ELSE 'any'
    END AS has_purchase 
  , CASE has_purchase
   	  WHEN 1 THEN 'review' WHEN 0 THEN 'not review' ELSE 'any'
    END AS has_review 
  , CASE has_favorite
   	  WHEN 1 THEN 'favorite' WHEN 0 THEN 'not favorite' ELSE 'any'
    END AS has_favorite
  , users
  -- 전체 사용자 수를 기반으로 비율 구하기
  ,users * 100.0 
   / NULLIF(
     	SUM(CASE WHEN has_purchase IS NULL
                 AND has_review IS NULL
                 AND has_favorite IS NULL
            	 THEN users ELSE 0 END) OVER()
     	,0)
        AS ratio
  FROM action_venn_diagram 
  ORDER BY 1,2,3
```

#### Q : 왜 모든 액션이 NULL인 사용자 수가 전체 사용자 수를 나타낼까? 
- 이제 모든 액션이 NULL인 사용자 수가 전체 사용자 수를 나타내는 이유는 CUBE를 사용하여 모든 가능한 조합을 구한 결과입니다. CUBE는 모든 가능한 조합을 포함하므로 has_purchased, has_review, has_favorite 각각이 NULL인 경우도 포함됩니다. 이는 전체 사용자 수를 나타내기 위한 부분입니다. ChatGPT 가 말했다.

## 6. Decile 분석을 사용해 사용자를 10단계 그룹으로 나누기 

### 구매액이 많은 순서로 사용자 그룹을 10등분하는 쿼리 
```sql
WITH user_purchase_amount AS(
  SELECT user_id
        ,SUM(amount) AS purchase_amount
  FROM action_log
  WHERE action = 'purchase'
  GROUP BY user_id 

), user_with_decile AS(
  SELECT user_id
  		,purchase_amount
        ,ntile(10) OVER(ORDER BY purchase_amount DESC) AS decile
  FROM user_purchase_amount
)
SELECT *
FROM user_with_decile
```
#### NTILE
- NTILE() : PARTITION을 지정된 수 만큼의 등급으로 나누어 각 등급 번호를 출력

### 번외 _ 순위 함수 종류
- NTILE() : PARTITION을 지정된 수 만큼의 등급으로 나누어 각 등급 번호를 출력
- RANK() : 순위 값 중 동등 순위 번호는 같게 나오고 그 다음 순위를 다음 번호를 뺀 그 다음 값을 출력
- DENSE_RANK() : 순위 값 중 동등 순위 번호는 같게 나오고 그 다음 순위를 다음 번호로 출력
- 	우리가 아는 흔한 올림픽 
- ROW_NUMBER() : 동등 순위를 인식하지 않고 매번증가되는 번호를 출력
- 	그러니까 rank가 아니고 number
- LEAD(expr [,offset] [,default]) / LAG() : 지정된 칼럼의 이전, 이후의 행 값을 출력
- FIRST_VALUE() / LAST_VALUE() : 각 그룹별 첫 번째와 마지막값 하나만출력
- CUME_DIST() : 주어진 그룹에 대한 상대적인 누적분포도 값을 반환한다.
- 분포도 값(비율)이므로 반환 값의 범위는 0 초과 1이하 사이의 값을 반환한다.

출처 : https://jie0025.tistory.com/85

### 10분할한 DECILE들을 집계하는 쿼리 

```sql
WITH user_purchase_amount AS(
  SELECT user_id
        ,SUM(amount) AS purchase_amount
  FROM action_log
  WHERE action = 'purchase'
  GROUP BY user_id 

), user_with_decile AS(
  SELECT user_id
  		,purchase_amount
        ,ntile(10) OVER(ORDER BY purchase_amount DESC) AS decile
  FROM user_purchase_amount

), decile_with_purchase_amount AS(
  SELECT decile
       , SUM(purchase_amount) AS amount
       , AVG(purchase_amount) AS avg_amount
       , SUM(SUM(purchase_amount)) OVER(ORDER BY decile) AS cumulative_amount
       , SUM(SUM(purchase_amount)) OVER() AS total_amount
  FROM user_with_decile
  GROUP BY decile
)
SELECT *
FROM decile_with_purchase_amount;
```

### 구매액이 많은 decile 순서로 구성비와 구성비누계를 계산하는 쿼리
```sql
WITH user_purchase_amount AS(
  SELECT user_id
        ,SUM(amount) AS purchase_amount
  FROM action_log
  WHERE action = 'purchase'
  GROUP BY user_id 

), user_with_decile AS(
  SELECT user_id
  		,purchase_amount
        ,ntile(10) OVER(ORDER BY purchase_amount DESC) AS decile
  FROM user_purchase_amount

), decile_with_purchase_amount AS(
  SELECT decile
       , SUM(purchase_amount) AS amount
       , AVG(purchase_amount) AS avg_amount
       , SUM(SUM(purchase_amount)) OVER(ORDER BY decile) AS cumulative_amount
       , SUM(SUM(purchase_amount)) OVER() AS total_amount
  FROM user_with_decile
  GROUP BY decile
)
SELECT decile
	  ,amount
      ,avg_amount
      ,amount*100.0 / total_amount AS total_ratio
      ,cumulative_amount / total_amount AS cumulative_ratio
FROM decile_with_purchase_amount;
```
