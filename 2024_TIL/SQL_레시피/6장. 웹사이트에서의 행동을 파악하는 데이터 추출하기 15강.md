# 15강 사이트 내의 사용자 행동 파악하기 
## 1. 입구 페이지와 출구 페이지 집계하기 

### FIRST_VALUE와 LAST_VALUE
- 첫번째 값, 마지막 값 
```sql
WITH activity_log_with_landing_exit AS(
  SELECT 
         session
        ,path
        ,stamp
        ,FIRST_VALUE(path) OVER(PARTITION BY session ORDER BY stamp ASC
                               ROWS BETWEEN UNBOUNDED PRECDING 
                               AND UNBOUNDED FOLLOWING
                               ) AS landing 
    -- 윈도우 함수에서 ORDER BY를 지정한 경우의 윈도함수 파티션은 디폴트로 첫 행부터 현재 행까지 계산 (누적합 계산할 때와 마찬가지로), But 우리는 입구 페이지와 출구 페이지를 찾고 싶기 때문에
    -- ROWS BETWEEN~ 구문을 사용해 각 세션 내부의 모든 행을 대상으로 지정                                
        , LAST_VALUE(path) OVER(PARTITION BY session ORDER BY stamp ASC
                                ROWS BETWEEN UNBOUNDED PRECEDING 
                                AND UNBOUNDED FOLLOWING
                                ) AS exit
    FROM activity_log
)
```
[레퍼런스](https://guseowhtjs.tistory.com/entry/SQL-Server-%EC%B2%AB-%EB%B2%88%EC%A7%B8-%EA%B0%92-%ED%95%A8%EC%88%98-FIRSTVALUE-function)

### 각 세션의 입구 페이지와 출구 페이지를 기반으로 방문 횟수를 추출하는 쿼리 

```sql
WITH activity_log_with_landing_exit AS(
  SELECT 
         session
        ,path
        ,stamp
        ,FIRST_VALUE(path) OVER(PARTITION BY session ORDER BY stamp ASC
                               ROWS BETWEEN UNBOUNDED PRECEDING 
                               AND UNBOUNDED FOLLOWING
                               ) AS landing 
    -- 윈도우 함수에서 ORDER BY를 지정한 경우의 윈도함수 파티션은 디폴트로 첫 행부터 현재 행까지 계산 (누적합 계산할 때와 마찬가지로), But 우리는 입구 페이지와 출구 페이지를 찾고 싶기 때문에
    -- ROWS BETWEEN~ 구문을 사용해 각 세션 내부의 모든 행을 대상으로 지정                                
        , LAST_VALUE(path) OVER(PARTITION BY session ORDER BY stamp ASC
                                ROWS BETWEEN UNBOUNDED PRECEDING 
                                AND UNBOUNDED FOLLOWING
                                ) AS exit
    FROM activity_log
)
, landing_count AS(
    -- 입구 페이지의 방문 횟수 집계하기 
  SELECT landing AS path
        ,COUNT(DISTINCT session) AS count
  FROM activity_log_with_landing_exit
  GROUP BY landing 
)
, exit_count AS(
  -- 출구 페이지의 방문 횟수 집계하기
  SELECT exit AS path
        ,COUNT(DISTINCT session) AS count  
  FROM activity_log_with_landing_exit
  GROUP BY exit
)   
-- 입구 페이지와 출구 페이지 방문 횟수 결과를 한꺼번에 출력하기

SELECT 'landing' AS type, * FROM landing_count
UNION ALL
SELECT 'exit' AS type , * FROM exit_count;
```

### 어디에서 조회를 시작해서 어디에서 이탈하는지 집계하기 

```sql
WITH activity_log_with_landing_exit AS(
  SELECT 
         session
        ,path
        ,stamp
        ,FIRST_VALUE(path) OVER(PARTITION BY session ORDER BY stamp ASC
                               ROWS BETWEEN UNBOUNDED PRECEDING 
                               AND UNBOUNDED FOLLOWING
                               ) AS landing 
    -- 윈도우 함수에서 ORDER BY를 지정한 경우의 윈도함수 파티션은 디폴트로 첫 행부터 현재 행까지 계산 (누적합 계산할 때와 마찬가지로), But 우리는 입구 페이지와 출구 페이지를 찾고 싶기 때문에
    -- ROWS BETWEEN~ 구문을 사용해 각 세션 내부의 모든 행을 대상으로 지정                                
        , LAST_VALUE(path) OVER(PARTITION BY session ORDER BY stamp ASC
                                ROWS BETWEEN UNBOUNDED PRECEDING 
                                AND UNBOUNDED FOLLOWING
                                ) AS exit
    FROM activity_log
)

SELECT  landing 
  	  , exit
      , COUNT(DISTINCT session) AS count
FROM activity_log_with_landing_exit
GROUP BY landing,exit 
```
## 2. 이탈률과 직귀율 계산하기 
-- 다 했는데 깃헙 작성 중 노트북 꺼짐 
## 3. 성과로 이어지는 페이지 파악하기 
-- 다 했는데 깃헙 작성 중 노트북 꺼짐 
## 4. 페이지 가치 산출하기 
### 페이지 가치 할당을 계산하는 쿼리 
```sql
WITH 
activity_log_with_conversion_flag AS (
  SELECT session
        ,stamp
  		,path
  -- 성과를 발생시키는 컨버전 페이지의 이전 로그들 플래그로 구분하기
  -- stamp를 DESC로 했음으로 complete 이후 부터 누적합 임으로 이것이 가능
  		,SIGN(
          SUM(CASE WHEN path = '/complete' THEN 1 ELSE O END)
          OVER(PARTITION BY session ORDER BY stamp DESC 
               ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
          )AS has_conversion
  FROM activity_log
 
)
, activity_log_with_conversion_assing AS(
  SELECT session
  		,stamp
  		,path
  -- 성과에 이르기까지의 접근 로그를 오름차순 정렬
  		,ROW_NUMBER() OVER(PARTITION BY session ORDER BY stamp) AS asc_order
   -- 성과에 이르기까지의 접근 로그를 내림차순 정렬
  		,ROW_NUMBER() OVER(PARTITION BY session ORDER BY stamp DESC) AS desc_order 
  -- 성과에 이르기까지 접근 수 세기 
  		,COUNT(1) OVER(PARTITION BY session) AS page_count 
  -- 균등 분배
  		,1000.0 / COUNT(1) OVER(PARTITION BY session) AS fair_assign 
  -- 첫 페이지에 가치 부여 
  		, CASE WHEN 
  			ROW_NUMBER() OVER(PARTITION BY session ORDER BY stamp ASC) = 1 
  			THEN 1000.0 
  			ELSE 0.0
  			END AS first_assign
  -- 마지막 페이지에 가치 부여 
  		, CASE WHEN 
  			ROW_NUMBER() OVER(PARTITION BY session ORDER BY stamp DESC) = 1 
  			THEN 1000.0 
  			ELSE 0.0
  			END AS last_assign  
  -- 성과 가까울 수록 높은 가치 부여하기 
  		, 1000
  			* ROW_NUMBER() OVER(PARTITION BY session ORDER BY stamp)
  		- n~ n+1 순번 의 합계로 나누기 = n*(n+1)/2
  		/ ( COUNT(1) OVER(PARTITION BY session) 
          * ( COUNT(1) OVER(PARTITION BY session) + 1 ) 
           /2) AS dec_a
  -- 성과 멀 수록 높은 가치 부여하기 
  		, 1000
  			* ROW_NUMBER() OVER(PARTITION BY session ORDER BY stamp DESC)
  		- n~ n+1 순번 의 합계로 나누기 = n*(n+1)/2
  		/ ( COUNT(1) OVER(PARTITION BY session) 
          * ( COUNT(1) OVER(PARTITION BY session) + 1 ) 
           /2) AS inc_a
  FROM activity_log_with_conversion_flag 
  WHERE has_conversion = 1 
  -- 입력,확인,완료 페이지 제외하기
  AND path NOT IN ('input','/confirm','/complete')
 ) 
 
``` 
